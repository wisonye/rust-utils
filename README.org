* My Rust utilities

This is my personal =Rust= utilities which contains the following modules:


** =logger=

This logger utility prints the log content based on the =LOG_LEVEL= env variable:

~LOG_LEVEL="DEBUG"~: Print all function calls: debug_log/info_log/warn_log/error_log
~LOG_LEVEL="INFO"~ : Only print function calls: info_log/warn_log/error_log
~LOG_LEVEL="WARN"~ : Only print function calls: warn_log/error_log
~LOG_LEVEL="ERROR"~: Only print function calls: error_log

If =LOG_LEVEL= is not provided, treat it as LOG_LEVEL="ERROR".

Example:

#+BEGIN_SRC rust-ts
  use rust_utils::utils::logger;

  logger::debug_log("Main", "main", format!("p: {p:?}").as_str());
  logger::info_log("Main", "main", format!("p: {p:?}").as_str());
  logger::warn_log("Main", "main", format!("p: {p:?}").as_str());
  logger::error_log("Main", "main", format!("p: {p:?}").as_str());
#+END_SRC

Now, you can run like this:

#+BEGIN_SRC bash
  LOG_LEVEL="DEBUG" cargo run
#+END_SRC

If you want, you can turn off the ANSI colour escape output like this:

#+BEGIN_SRC bash
  LOGGER_DISABLE_COLOR="TRUE" LOG_LEVEL="DEBUG" cargo run
#+END_SRC



** =memory=

Memory util, it provides the following functions:

*** =print_memory_block=

Print the memory layout of the given variable.

Example:

#+BEGIN_SRC rust-ts
  use rust_utils::utils::memory;

  let temp_u8 = 0x31u8;
  print_memory(&temp_u8, "temp_u8");

  let temp_int = 0xAABBu32;
  print_memory(&temp_int, "temp_int");


  let temp_float = 123.13456f32;
  print_memory(&temp_float, "temp_float");


  struct Point { x: u16, y: u16 };
  let p = Point { x: 0xAA, y: 0xBB };
  print_memory(&p, "p");

  struct Person {
      first_name: &'static str,
      last_name: &'static str,
      age: u8
  }

  let me = Person {
      first_name: "123",
      last_name: "456",
      age: 0xFF,
  };
  print_memory(&me, "me");
#+END_SRC

Example output:

#+BEGIN_SRC bash
  (D) [ Memory - print_memory ] 'temp_u8', size: 1
  (D) [ Memory - print_memory ] ------------------
  (D) [ Memory - print_memory ] 31
  (D) [ Memory - print_memory ] ------------------

  (D) [ Memory - print_memory ] 'temp_int', size: 4
  (D) [ Memory - print_memory ] -------------------
  (D) [ Memory - print_memory ] BBAA0000
  (D) [ Memory - print_memory ] -------------------

  (D) [ Memory - print_memory ] 'temp_float', size: 4
  (D) [ Memory - print_memory ] ---------------------
  (D) [ Memory - print_memory ] E544F642
  (D) [ Memory - print_memory ] ---------------------

  (D) [ Memory - print_memory ] 'p', size: 4
  (D) [ Memory - print_memory ] ------------
  (D) [ Memory - print_memory ] AA00BB00
  (D) [ Memory - print_memory ] ------------

  (D) [ Memory - print_memory ] 'me', size: 40
  (D) [ Memory - print_memory ] --------------------------------------------------------------------------------
  (D) [ Memory - print_memory ] 4A39A3070100000003000000000000004D39A307010000000300000000000000FF00000000000000
  (D) [ Memory - print_memory ] --------------------------------------------------------------------------------
#+END_SRC


  
*** =print_memory_for_slice=

Print the memory layout from the inner buffer of the given slice.

Example:

#+BEGIN_SRC rust-ts
  use rust_utils::utils::memory;  

  #[derive(Debug, Clone)]
  struct Point {
      x: u16,
      y: u16,
  }

  let mut point_list = Vec::with_capacity(2);
  point_list.push(Point { x: 0x11, y: 0x22 });
  point_list.push(Point { x: 0x33, y: 0x44 });
  point_list.push(Point { x: 0x55, y: 0x66 });
  point_list.push(Point { x: 0x77, y: 0x88 });
  point_list.push(Point { x: 0xAABB, y: 0xCCDD });

  print_memory_for_slice(&point_list[..], "point_list slice");

  let temp_arr = vec![0xAAusize, 0xBB, 0xCC];
  print_memory_for_slice(&temp_arr[..], "temp_arr slice");

  //
  // You can call `.as_bytes()` to get back a `&[u8]` from the
  // `String` inner buffer.
  //
  let my_name = String::from("123456789");
  print_memory_for_slice(my_name.as_bytes(), "my_name slice");
#+END_SRC


Example output:

#+BEGIN_SRC bash
  (D) [ Memory - print_memory ] 'point_list slice', element byte size: 4, len: 5
  (D) [ Memory - print_memory ] ------------------------------------------------
  (D) [ Memory - print_memory ] 11002200|33004400|55006600|77008800|BBAADDCC
  (D) [ Memory - print_memory ] ------------------------------------------------

  (D) [ Memory - print_memory ] 'temp_arr slice', element byte size: 8, len: 3
  (D) [ Memory - print_memory ] --------------------------------------------------
  (D) [ Memory - print_memory ] AA00000000000000|BB00000000000000|CC00000000000000
  (D) [ Memory - print_memory ] --------------------------------------------------

  (D) [ Memory - print_memory ] 'my_name slice', element byte size: 1, len: 9
  (D) [ Memory - print_memory ] ---------------------------------------------
  (D) [ Memory - print_memory ] 31|32|33|34|35|36|37|38|39
  (D) [ Memory - print_memory ] ---------------------------------------------
#+END_SRC


** =hex=

Hex util, it provides the following functions:

- =byte_arr_to_hex_string=
- =hex_string_to_byte_arr=
- =hex_to_be_u16=
- =hex_to_be_u32=

Example:

*** Get back hex string from byte array:

#+BEGIN_SRC rust-ts
  use rust_utils::utils::{hex, logger};

  let hex_arr = vec![0xAAu8, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF];
  let hex_str = hex::byte_arr_to_hex_string(&hex_arr, None);
  logger::debug_log("Main", "main", &format!("hex_str: {hex_str}"));

  let hex_str_with_space = hex::byte_arr_to_hex_string(&hex_arr, Some(' '));
  logger::debug_log(
      "Main",
      "main",
      &format!(">>> hex_str_with_space: '{hex_str_with_space}'"),
  );
#+END_SRC

Output:

#+BEGIN_SRC bash
  (D) [ Main - main ] hex_str: AABBCCDDEEFF
  (D) [ Main - main ] >>> hex_str_with_space: 'AA BB CC DD EE FF'
#+END_SRC


*** Get back byte array from hex string

#+BEGIN_SRC rust-ts
  use rust_utils::utils::hex;

  let hex_str = "0A1B2C3D4E5F";
  let result = hex::hex_string_to_byte_arr(&hex_str);

  assert_eq!(result.is_ok(), true);
  let byte_arr = result.unwrap();
  assert_eq!(byte_arr.len(), 6);
  assert_eq!(byte_arr[0], 0x0A);
  assert_eq!(byte_arr[1], 0x1B);
  assert_eq!(byte_arr[2], 0x2C);
  assert_eq!(byte_arr[3], 0x3D);
  assert_eq!(byte_arr[4], 0x4E);
  assert_eq!(byte_arr[5], 0x5F);
#+END_SRC


** =Bits=

Bits util, it provides the following functions:

- =print_bits=
- =get_bits=
- =is_bit_1=

Example

*** Print bits

#+BEGIN_SRC rust-ts
  use rust_utils::utils::bits;

  bits::print_bits::<u8>(&0x08u8);
  bits::print_bits::<u16>(&0xABCDu16);
  bits::print_bits::<u32>(&0x889Eu32);
  bits::print_bits::<u32>(&0xFB56889Eu32);
  bits::print_bits::<u64>(&0x1234C78AFB56889Eu64);
#+END_SRC

Output:

#+BEGIN_SRC bash
  (D) [ Bits - print_bits ] 0x08 bits: 00001000
  (D) [ Bits - print_bits ] 0xABCD bits: 1010101111001101
  (D) [ Bits - print_bits ] 0x0000889E bits: 00000000000000001000100010011110
  (D) [ Bits - print_bits ] 0xFB56889E bits: 11111011010101101000100010011110
  (D) [ Bits - print_bits ] 0x1234C78AFB56889E bits: 0001001000110100110001111000101011111011010101101000100010011110
#+END_SRC


*** Get bits

#+BEGIN_SRC rust-ts
  use rust_utils::utils::bits;

  let u8_bits = bits::get_bits::<u8>(&0x08u8);
  assert_eq!(u8_bits, "00001000");

  let u16_bits = bits::get_bits::<u16>(&0xABCDu16);
  assert_eq!(u16_bits, "1010101111001101");

  let u32_bits = bits::get_bits::<u32>(&0x889Eu32);
  assert_eq!(u32_bits, "00000000000000001000100010011110");

  let u32_bits_2 = bits::get_bits::<u32>(&0xFB56889Eu32);
  assert_eq!(u32_bits_2, "11111011010101101000100010011110");

  let u64_bits = bits::get_bits::<u64>(&0x1234C78AFB56889Eu64);
  assert_eq!(
      u64_bits,
      "0001001000110100110001111000101011111011010101101000100010011110"
  );
#+END_SRC


*** Check whether the given bit is set (`1`) or not

#+BEGIN_SRC rust-ts
  use rust_utils::utils::{bits, logger};

  let v: usize = 0xABCD;

  logger::debug_log("Main", "main", &format!("0x{:04X} bits: {:016b}", v, v));

  for which_bit in 1..17 {
      logger::debug_log(
          "Main",
          "main",
          &format!(
              "bit {:2} in '0x{:02X}' is 1?: {}",
              which_bit,
              v,
              bits::bit_is_1(v as usize, which_bit)
          ),
      );
  }
#+END_SRC


Output:

#+BEGIN_SRC bash
  (D) [ Main - main ] 0xABCD bits: 1010101111001101
  (D) [ Main - main ] bit  1 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit  2 in '0xABCD' is 1?: false
  (D) [ Main - main ] bit  3 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit  4 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit  5 in '0xABCD' is 1?: false
  (D) [ Main - main ] bit  6 in '0xABCD' is 1?: false
  (D) [ Main - main ] bit  7 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit  8 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit  9 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit 10 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit 11 in '0xABCD' is 1?: false
  (D) [ Main - main ] bit 12 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit 13 in '0xABCD' is 1?: false
  (D) [ Main - main ] bit 14 in '0xABCD' is 1?: true
  (D) [ Main - main ] bit 15 in '0xABCD' is 1?: false
  (D) [ Main - main ] bit 16 in '0xABCD' is 1?: true
#+END_SRC



** How to run test

#+BEGIN_SRC fish
  cargo test --lib

  #
  # If you t want to print all `debug_log` output
  #
  LOG_LEVEL="DEBUG" cargo test --lib -- --nocapture
#+END_SRC

